diff -Naur wine-0.9.33.orig/dlls/wineasio/asio.c wine-0.9.33.asio/dlls/wineasio/asio.c
--- wine-0.9.33.orig/dlls/wineasio/asio.c	2007-03-29 23:20:14.000000000 +0200
+++ wine-0.9.33.asio/dlls/wineasio/asio.c	2007-03-29 23:21:01.000000000 +0200
@@ -82,8 +82,9 @@
 #define twoRaisedTo32           4294967296.0
 #define twoRaisedTo32Reciprocal	(1.0 / twoRaisedTo32)
 
-#define MAX_INPUTS      2
-#define MAX_OUTPUTS     2
+#define MAX_INPUTS     2
+#define MAX_OUTPUTS    2 
+#define MAX_BUFFERSIZE 1024
 
 /* ASIO drivers use the thiscall calling convention which only Microsoft compilers
  * produce.  These macros add an extra layer to fixup the registers properly for
@@ -156,6 +157,12 @@
     Exit
 };
 
+typedef struct _Channel {
+   ASIOBool active;
+   float buffer[MAX_BUFFERSIZE*2];
+   jack_port_t *port;
+} Channel;
+
 struct IWineASIOImpl
 {
     /* COM stuff */
@@ -175,21 +182,13 @@
     ASIOBufferInfo      *bufferInfos;
     ASIOCallbacks       *callbacks;
     char                error_message[256];
-    long                in_map[MAX_INPUTS];
-    long                out_map[MAX_OUTPUTS];
-    long                num_inputs;
-    long                num_outputs;
-    float               *input_buffers[MAX_INPUTS][2];
-    float               *output_buffers[MAX_OUTPUTS][2];
-    long                active_inputs;
-    long                active_outputs;
+    Channel             input[MAX_INPUTS];
+    Channel             output[MAX_OUTPUTS];
     BOOL                time_info_mode;
     BOOL                tc_read;
     long                state;
 
     /* JACK stuff */
-    jack_port_t         *input_port[MAX_INPUTS];
-    jack_port_t         *output_port[MAX_OUTPUTS];
     jack_client_t       *client;
     long                client_state;
     long                toggle;
@@ -206,6 +205,11 @@
 
 typedef struct IWineASIOImpl              IWineASIOImpl;
 
+//#undef WARN
+//#define WARN printf
+//#undef TRACE
+//#define TRACE printf
+
 static ULONG WINAPI IWineASIOImpl_AddRef(LPWINEASIO iface)
 {
     IWineASIOImpl *This = (IWineASIOImpl *)iface;
@@ -265,7 +269,7 @@
 {
     IWineASIOImpl * This = (IWineASIOImpl*)iface;
     jack_status_t status;
-    int i;
+    int i,j;
     TRACE("(%p, %p)\n", iface, sysHandle);
 
     This->sample_rate = 48000.0;
@@ -276,10 +280,6 @@
     This->callbacks = NULL;
     This->sample_position = 0;
     strcpy(This->error_message, "No Error");
-    This->num_inputs = 0;
-    This->num_outputs = 0;
-    This->active_inputs = 0;
-    This->active_outputs = 0;
     This->toggle = 1;
     This->client_state = Init;
     This->time_info_mode = FALSE;
@@ -287,6 +287,24 @@
     This->terminate = FALSE;
     This->state = Init;
 
+    // initialize input buffers
+
+    for (i=0; i<MAX_INPUTS; i++) {
+        This->input[i].active = ASIOFalse;
+        for (j=0; j<MAX_BUFFERSIZE * 2; j++)
+            This->input[i].buffer[j] = 0.0;
+        This->input[i].port = 0;
+    }
+
+    // initialize output buffers
+
+    for (i=0; i<MAX_OUTPUTS; i++) {
+        This->output[i].active = ASIOFalse;
+        for (j=0; j<MAX_BUFFERSIZE * 2; j++)
+            This->output[i].buffer[j] = 0.0;
+        This->output[i].port = 0;
+    }
+
     sem_init(&This->semaphore1, 0, 0);
     sem_init(&This->semaphore2, 0, 0);
 
@@ -305,16 +323,6 @@
         return ASIOFalse;
     }
 
-    for (i = 0; i < MAX_INPUTS; i++)
-    {
-        This->in_map[i] = 0;
-    }
-
-    for (i = 0; i < MAX_OUTPUTS; i++)
-    {
-        This->out_map[i] = 0;
-    }
-
     This->client = fp_jack_client_open("Wine_ASIO_Jack_Client", JackNullOption, &status, NULL);
     if (This->client == NULL)
     {
@@ -330,6 +338,7 @@
     fp_jack_set_process_callback(This->client, jack_process, This);
 
     This->sample_rate = fp_jack_get_sample_rate(This->client);
+    This->block_frames = fp_jack_get_buffer_size(This->client);
     This->miliseconds = (long)((double)(This->block_frames * 1000) / This->sample_rate);
 
     TRACE("sample rate: %f\n", This->sample_rate);
@@ -338,28 +347,16 @@
     {
         char name[32];
         snprintf(name, sizeof(name), "Input%d", i);
-        This->input_port[i] = fp_jack_port_register(This->client, name, JACK_DEFAULT_AUDIO_TYPE, JackPortIsInput, i);
-        if (This->input_port[i] == 0)
-            break;
-
-        This->num_inputs++;
+        This->input[i].port = fp_jack_port_register(This->client, name, JACK_DEFAULT_AUDIO_TYPE, JackPortIsInput, i);
     }
 
-    TRACE("found %ld inputs\n", This->num_inputs);
-
     for (i = 0; i < MAX_OUTPUTS; i++)
     {
         char name[32];
         snprintf(name, sizeof(name), "Output%d", i);
-        This->output_port[i] = fp_jack_port_register(This->client, name, JACK_DEFAULT_AUDIO_TYPE, JackPortIsOutput, i);
-        if (This->output_port[i] == 0)
-            break;
-
-        This->num_outputs++;
+        This->output[i].port = fp_jack_port_register(This->client, name, JACK_DEFAULT_AUDIO_TYPE, JackPortIsOutput, i);
     }
 
-    TRACE("found %ld outputs\n", This->num_outputs);
-
     return ASIOTrue;
 }
 
@@ -372,7 +369,7 @@
 WRAP_THISCALL( long __stdcall, IWineASIOImpl_getDriverVersion, (LPWINEASIO iface))
 {
     TRACE("(%p)\n", iface);
-    return 1;
+    return 2;
 }
 
 WRAP_THISCALL( void __stdcall, IWineASIOImpl_getErrorMessage, (LPWINEASIO iface, char *string))
@@ -409,14 +406,15 @@
             return ASE_NotPresent;
         }
 
-        for (i = 0; i < This->active_inputs; i++)
+        for (i = 0; i < MAX_INPUTS; i++)
         {
-            if (fp_jack_connect(This->client, ports[i], fp_jack_port_name(This->input_port[i])))
-            {
-                WARN("input %d connect failed\n", i);
-                free(ports);
-                return ASE_NotPresent;
-            }
+            if (This->input[i].active == ASIOTrue)
+               if (fp_jack_connect(This->client, ports[i], fp_jack_port_name(This->input[i].port)))
+               {
+                   WARN("input %d connect failed\n", i);
+                   free(ports);
+                   return ASE_NotPresent;
+               }
         }
 
         free(ports);
@@ -429,14 +427,15 @@
             return ASE_NotPresent;
         }
 
-        for (i = 0; i < This->active_outputs; i++)
+        for (i = 0; i < MAX_OUTPUTS; i++)
         {
-            if (fp_jack_connect(This->client, fp_jack_port_name(This->output_port[i]), ports[i]))
-            {
-                WARN("output %d connect failed\n", i);
-                free(ports);
-                return ASE_NotPresent;
-            }
+            if (This->output[i].active == ASIOTrue)
+               if (fp_jack_connect(This->client, fp_jack_port_name(This->output[i].port), ports[i]))
+               {
+                   WARN("output %d connect failed\n", i);
+                   free(ports);
+                   return ASE_NotPresent;
+               }
         }
 
         free(ports);
@@ -472,10 +471,10 @@
     TRACE("(%p, %p, %p)\n", iface, numInputChannels, numOutputChannels);
 
     if (numInputChannels)
-        *numInputChannels = This->num_inputs;
+        *numInputChannels = MAX_INPUTS;
 
     if (numOutputChannels)
-        *numOutputChannels = This->num_outputs;
+        *numOutputChannels = MAX_OUTPUTS;
 
     return ASE_OK;
 }
@@ -544,17 +543,6 @@
     if (sampleRate != This->sample_rate)
         return ASE_NoClock;
 
-    if (sampleRate != This->sample_rate)
-    {
-        This->sample_rate = sampleRate;
-        This->asio_time.timeInfo.sampleRate = sampleRate;
-        This->asio_time.timeInfo.flags |= kSampleRateChanged;
-        This->miliseconds = (long)((double)(This->block_frames * 1000) / This->sample_rate);
-
-        if (This->callbacks && This->callbacks->sampleRateDidChange)
-            This->callbacks->sampleRateDidChange(This->sample_rate);
-    }
-
     return ASE_OK;
 }
 
@@ -621,37 +609,21 @@
     char name[32];
     TRACE("(%p, %p)\n", iface, info);
 
+    printf("channel %s %d\n", info->isInput ? "input" : "output" , info->channel);
     if (info->channel < 0 || (info->isInput ? info->channel >= MAX_INPUTS : info->channel >= MAX_OUTPUTS))
         return ASE_InvalidParameter;
 
     info->type = ASIOSTFloat32LSB;
     info->channelGroup = 0;
-    info->isActive = ASIOFalse;
 
     if (info->isInput)
     {
-        for (i = 0; i < This->active_inputs; i++)
-        {
-            if (This->in_map[i] == info->channel)
-            {
-                info->isActive = ASIOTrue;
-                break;
-            }
-        }
-
+        info->isActive = This->input[info->channel].active;
         snprintf(name, sizeof(name), "Input %ld", info->channel);
     }
     else
     {
-        for (i = 0; i < This->active_outputs; i++)
-        {
-            if (This->out_map[i] == info->channel)
-            {
-                info->isActive = ASIOTrue;
-                break;
-            }
-        }
-
+        info->isActive = This->input[info->channel].active;
         snprintf(name, sizeof(name), "Output %ld", info->channel);
     }
 
@@ -669,22 +641,16 @@
     This->callbacks = NULL;
     __wrapped_IWineASIOImpl_stop(iface);
 
-    for (i = 0; i < This->active_inputs; i++)
+    for (i = 0; i < MAX_INPUTS; i++)
     {
-        HeapFree(GetProcessHeap(), 0, This->input_buffers[i][0]);
-        HeapFree(GetProcessHeap(), 0, This->input_buffers[i][1]);
+        This->input[i].active = ASIOFalse;
     }
 
-    This->active_inputs = 0;
-
-    for (i = 0; i < This->active_outputs; i++)
+    for (i = 0; i < MAX_OUTPUTS; i++)
     {
-        HeapFree(GetProcessHeap(), 0, This->output_buffers[i][0]);
-        HeapFree(GetProcessHeap(), 0, This->output_buffers[i][1]);
+        This->output[i].active = ASIOFalse;
     }
 
-    This->active_outputs = 0;
-
     return ASE_OK;
 }
 
@@ -695,79 +661,40 @@
     int i;
     TRACE("(%p, %p, %ld, %ld, %p)\n", iface, bufferInfos, numChannels, bufferSize, callbacks);
 
-    This->active_inputs = 0;
-    This->active_outputs = 0;
+    printf("buffersize %d\n", bufferSize);
+
     This->block_frames = bufferSize;
     This->miliseconds = (long)((double)(This->block_frames * 1000) / This->sample_rate);
 
-    printf("buffersize %d\n", bufferSize);
-
     for (i = 0; i < numChannels; i++, info++)
     {
         if (info->isInput)
         {
             printf("input\n");
-            if (info->channelNum < 0 || info->channelNum >= This->num_inputs)
+            if (info->channelNum < 0 || info->channelNum >= MAX_INPUTS)
             {
                 WARN("invalid input channel: %ld\n", info->channelNum);
                 goto ERROR_PARAM;
             }
 
-            if (This->active_inputs >= This->num_inputs)
-            {
-                WARN("too many inputs\n");
-                goto ERROR_PARAM;
-            }
+            This->input[info->channelNum].active = ASIOTrue;
+            info->buffers[0] = &This->input[info->channelNum].buffer[0];
+            info->buffers[1] = &This->input[info->channelNum].buffer[MAX_BUFFERSIZE];
 
-            This->in_map[This->active_inputs] = info->channelNum;
-            This->input_buffers[This->active_inputs][0] = HeapAlloc(GetProcessHeap(), 0, This->block_frames * sizeof(float));
-            This->input_buffers[This->active_inputs][1] = HeapAlloc(GetProcessHeap(), 0, This->block_frames * sizeof(float));
-            if (This->input_buffers[This->active_inputs][0] && This->input_buffers[This->active_inputs][1])
-            {
-                info->buffers[0] = This->input_buffers[This->active_inputs][0];
-                info->buffers[1] = This->input_buffers[This->active_inputs][1];
-            }
-            else
-            {
-                HeapFree(GetProcessHeap(), 0, This->input_buffers[This->active_inputs][0]);
-                info->buffers[0] = 0;
-                info->buffers[1] = 0;
-                WARN("no input buffer memory\n");
-                goto ERROR_MEM;
-            }
-            This->active_inputs++;
         }
         else
         {
-            if (info->channelNum < 0 || info->channelNum >= This->num_outputs)
+            printf("output\n");
+            if (info->channelNum < 0 || info->channelNum >= MAX_OUTPUTS)
             {
                 WARN("invalid output channel: %ld\n", info->channelNum);
                 goto ERROR_PARAM;
             }
 
-            if (This->active_outputs >= This->num_outputs)
-            {
-                WARN("too many outputs\n");
-                goto ERROR_PARAM;
-            }
+            This->output[info->channelNum].active = ASIOTrue;
+            info->buffers[0] = &This->output[info->channelNum].buffer[0];
+            info->buffers[1] = &This->output[info->channelNum].buffer[MAX_BUFFERSIZE];
 
-            This->out_map[This->active_outputs] = info->channelNum;
-            This->output_buffers[This->active_outputs][0] = HeapAlloc(GetProcessHeap(), 0, This->block_frames * sizeof(float));
-            This->output_buffers[This->active_outputs][1] = HeapAlloc(GetProcessHeap(), 0, This->block_frames * sizeof(float));
-            if (This->output_buffers[This->active_outputs][0] && This->output_buffers[This->active_outputs][1])
-            {
-                info->buffers[0] = This->output_buffers[This->active_outputs][0];
-                info->buffers[1] = This->output_buffers[This->active_outputs][1];
-            }
-            else
-            {
-                HeapFree(GetProcessHeap(), 0, This->output_buffers[This->active_outputs][0]);
-                info->buffers[0] = 0;
-                info->buffers[1] = 0;
-                WARN("no output buffer memory\n");
-                goto ERROR_MEM;
-            }
-            This->active_outputs++;
         }
     }
 
@@ -961,7 +888,8 @@
     int i, j;
     jack_default_audio_sample_t *in, *out;
     jack_transport_state_t ts;
-    
+    float *buffer;
+
  //   ts = fp_jack_transport_query(This->client, NULL);
 
  //   if (ts == JackTransportRolling)
@@ -969,40 +897,45 @@
         if (This->client_state == Init)
             This->client_state = Run;
 
-        This->toggle = This->toggle ? 0 : 1;
         This->sample_position += nframes;
+        getNanoSeconds(&This->system_time);
 
         /* get the input data from JACK and copy it to the ASIO buffers */
-//        for (i = 0; i < This->active_inputs; i++)
-//        {
-//            float * buffer = This->input_buffers[i][This->toggle];
-//
-//            in = fp_jack_port_get_buffer(This->input_port[i], nframes);
-//
-//            for (j = 0; j < nframes; j++)
-//                buffer[j] = in[j];
-//        }
+        for (i = 0; i < MAX_INPUTS; i++)
+        {
+            if (This->input[i].active == ASIOTrue) {
+
+               buffer = &This->input[i].buffer[MAX_BUFFERSIZE * This->toggle];
+               in = fp_jack_port_get_buffer(This->input[i].port, nframes);
+
+               for (j = 0; j < nframes; j++)
+                   buffer[j] = in[j];
+
+            }
+        }
 
         /* call the ASIO user callback to read the input data and fill the output data */
-//        getNanoSeconds(&This->system_time);
 
         /* wake up the WIN32 thread so it can do the do it's callback */
-//        sem_post(&This->semaphore1);
+        sem_post(&This->semaphore1);
 
-        This->callbacks->bufferSwitch(This->toggle, ASIOFalse);
+//        This->callbacks->bufferSwitch(This->toggle, ASIOTrue);
 
         /* wait for the WIN32 thread to complete before continuing */
-//        sem_wait(&This->semaphore2);
+        sem_wait(&This->semaphore2);
 
         /* copy the ASIO data to JACK */
-        for (i = 0; i < This->active_outputs; i++)
+        for (i = 0; i < MAX_OUTPUTS; i++)
         {
-            float * buffer = This->output_buffers[i][(This->toggle+1)&1];
+            if (This->output[i].active == ASIOTrue) {
 
-            out = fp_jack_port_get_buffer(This->output_port[i], nframes);
+               buffer = &This->output[i].buffer[MAX_BUFFERSIZE * (This->toggle ? 0 : 1)];
+               out = fp_jack_port_get_buffer(This->output[i].port, nframes);
 
-            for (j = 0; j < nframes; j++)
-                out[j] = buffer[j];
+               for (j = 0; j < nframes; j++) 
+                   out[j] = buffer[j];
+
+            }
         }
    // }
    // else if (ts == JackTransportStopped)
@@ -1016,6 +949,8 @@
    //     }
    // }
 
+    This->toggle = This->toggle ? 0 : 1;
+
     return 0;
 }
 
@@ -1030,13 +965,12 @@
     IWineASIOImpl * This = (IWineASIOImpl*)arg;
     TRACE("(%p)\n", arg);
     
-    attr.sched_priority = 1;
+    attr.sched_priority = 80;
+    sched_setscheduler(0, SCHED_FIFO, &attr);
 
     /* let IWineASIO_Init know we are alive */
     SetEvent(This->start_event);
 
-    sched_setscheduler(0, SCHED_FIFO, &attr);
-
     while (1)
     {
         /* wait to be woken up by the JAck callback thread */
@@ -1053,21 +987,22 @@
         /* make sure we are in the run state */
         if (This->state == Run)
         {
-//            if (This->time_info_mode)
-//            {
-//                __wrapped_IWineASIOImpl_getSamplePosition((LPWINEASIO)This,
-//                    &This->asio_time.timeInfo.samplePosition, &This->asio_time.timeInfo.systemTime);
-//                if (This->tc_read)
-//                {
-//                    /* FIXME */
-//                    This->asio_time.timeCode.timeCodeSamples.lo = This->asio_time.timeInfo.samplePosition.lo;
-//                    This->asio_time.timeCode.timeCodeSamples.hi = 0;
-//                }
-//                This->callbacks->bufferSwitchTimeInfo(&This->asio_time, This->toggle, ASIOFalse);
-//                This->asio_time.timeInfo.flags &= ~(kSampleRateChanged | kClockSourceChanged);
-//            }
-//            else
-                This->callbacks->bufferSwitch(This->toggle, ASIOFalse);
+            if (This->time_info_mode)
+            {
+                __wrapped_IWineASIOImpl_getSamplePosition((LPWINEASIO)This,
+                    &This->asio_time.timeInfo.samplePosition, &This->asio_time.timeInfo.systemTime);
+                if (This->tc_read)
+                {
+                    /* FIXME */
+                    This->asio_time.timeCode.timeCodeSamples.lo = This->asio_time.timeInfo.samplePosition.lo;
+                    This->asio_time.timeCode.timeCodeSamples.hi = 0;
+                }
+                This->callbacks->bufferSwitchTimeInfo(&This->asio_time, This->toggle, ASIOTrue);
+                This->asio_time.timeInfo.flags &= ~(kSampleRateChanged | kClockSourceChanged);
+            }
+            else {
+                This->callbacks->bufferSwitch(This->toggle, ASIOTrue);
+            }
         }
 
         /* let the Jack thread know we are done */
